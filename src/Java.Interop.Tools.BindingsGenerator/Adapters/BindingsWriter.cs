using Javil;
using Xamarin.SourceWriter;

namespace Java.Interop.Tools.BindingsGenerator;

public class BindingsWriter
{
	readonly string output_dir;

	public BindingsWriter (string outputDir)
	{
		output_dir = outputDir;
	}

	public void WriteProject (ContainerDefinition container)
	{
		MicrosoftAndroidFixups.ApplyContainerFixups (container);
		JavaBaseFixups.ApplyContainerFixups (container);
		TypeVisibilityFixup.Run (container);
		ProtectedBaseMethodFixup.Run (container);
		ImplementedInterfaceFixup.Run (container);
		DefaultInterfaceImplementationFixup.Run (container);

		//Parallel.ForEach (container.Types.Where (t => t.IsPublic || t.IsProtected).ToList (), (type) => { WriteType (type); });

		foreach (var type in container.Types.Where (t => t.IsPublicApi ()))
			WriteType (type);
	}

	private void WriteType (TypeDefinition type)
	{
		using var writer = new CodeWriter (Path.Combine (output_dir, type.GetNamespace () + "." + type.Name + ".cs"));

		writer.WriteLine ("//------------------------------------------------------------------------------");
		writer.WriteLine ("// <auto-generated>");
		writer.WriteLine ("//     This code was generated by a tool.");
		writer.WriteLine ("//");
		writer.WriteLine ("//     Changes to this file may cause incorrect behavior and will be lost if");
		writer.WriteLine ("//     the code is regenerated.");
		writer.WriteLine ("// </auto-generated>");
		writer.WriteLine ("//------------------------------------------------------------------------------");
		writer.WriteLine ();

		writer.WriteLine ($"#nullable restore");
		writer.WriteLine ();

		writer.WriteLine ($"namespace {type.GetNamespace ()};");
		writer.WriteLine ();

		var t = CreateType (type);
		MicrosoftAndroidFixups.ApplyTypeFixups (t);
		JavaBaseFixups.ApplyTypeFixups (t);
		t.Write (writer);
	}

	private TypeWriter CreateType (TypeDefinition type)
	{
		if (type.IsInterface)
			return CreateInterface (type);

		return CreateClass (type);
	}

	private ClassWriter CreateClass (TypeDefinition type)
	{
		var klass = BoundClass.Create (type);

		foreach (var nested in type.NestedTypes.Where (t => t.IsPublic || t.IsProtected))
			klass.NestedTypes.Add (CreateType (nested));

		return klass;
	}

	private InterfaceWriter CreateInterface (TypeDefinition type)
	{
		var iface = BoundInterface.Create (type);

		foreach (var nested in type.NestedTypes.Where (t => t.IsPublic || t.IsProtected))
			iface.NestedTypes.Add (CreateType (nested));

		return iface;
	}
}
